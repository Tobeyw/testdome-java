import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class MalwareAnalysis {
    public static int[] simulate2(int[] entries) {
       // throw new UnsupportedOperationException("Waiting to be implemented.");
        if (entries.length < 8) {
            return  entries;
        }
       
       int tlOffset = -3; 
       int trOffset = 4; 
       boolean[] toZero = new boolean[entries.length];

       for (int i = 0; i < entries.length; i++) {
           int tlIndex = i + tlOffset;
           int trIndex = i + trOffset;

           boolean tlInRange = tlIndex >= 0 && tlIndex < entries.length;
           boolean trInRange = trIndex >= 0 && trIndex < entries.length;

           if ((tlInRange && entries[tlIndex] >= entries[i]) ||
               (trInRange && entries[trIndex] >= entries[i])) {
               toZero[i] = true;
           }
       }

       // Step 2: Set identified positions to 0
       for (int i = 0; i < entries.length; i++) {
           if (toZero[i]) {
            entries[i] = 0;
           }
       }

       return entries;
    }

    public static int[] simulate(int[] entries) {
        if (entries.length < 8) {
            return  entries;
        }
       
       int tlOffset = 3; 
       int trOffset = 4; 
        boolean[] toZero = new boolean[entries.length];

        // Step 1: Identify positions to set to 0
        for (int i = tlOffset+1; i < entries.length-trOffset; i++) {
            int leftIndex = i - tlOffset;
            int rightIndex = i + trOffset;
            boolean isZero = false;

            // Compare with the left offset value if it is in bounds
            if (leftIndex >= 0 && entries[leftIndex] >= entries[i]) {
                isZero = true;
            }

            // Compare with the right offset value if it is in bounds
            if (rightIndex < entries.length && entries[rightIndex] >= entries[i]) {
                isZero = true;
            }

            // Mark the position to be set to 0
            toZero[i] = isZero;
        }

        // Step 2: Apply the changes to the array
        for (int i = 0; i < entries.length; i++) {
            if (toZero[i]) {
                entries[i] = 0;
            }
        }

        return entries;
    }


     public static int[] simulateMalwareBehavior(int[] arr) {
        int Tl_offset = -3; 
        int Tr_offset = 4; 
        int n = arr.length;
        Set<Integer> toZero = new HashSet<>();

        // 第一步：确定需要设置为0的位置
        for (int i = 0; i < n; i++) {
            int Tl_index = i + Tl_offset;
            int Tr_index = i + Tr_offset;

            if ((Tl_index >= 0 && Tl_index < n && arr[Tl_index] >= arr[i]) || 
                (Tr_index >= 0 && Tr_index < n && arr[Tr_index] >= arr[i])) {
                toZero.add(i);
            }
        }

        // 第二步：将确定的位置设置为0
        for (int i : toZero) {
            arr[i] = 0;
        }

     
       return arr;
    }
    public static void main(String[] args) {
        int[] records = new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        System.out.println(Arrays.toString(simulate(records)));
        // Expected output:
        // 1, 0, 0, 5, 0, 0, 0, 3, 3, 0
    }
}